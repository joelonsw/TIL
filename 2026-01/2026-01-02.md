### 2026-01-02

## ES에서 한 번 인덱스된 필드는 고정된다
- **문제 상황**
  - body.contents를 로깅하는데, body.contents가 포맷이 다양함
    ```json
    {
      "contents": [
        "안녕"
      ]
    }
    ```
    ```json
    {
      "contents": [
        {
          "url": "https://alpha-k.kakaocdn.net/dna/yeszd/bIcnbl1bFPT/ucR5LMwHNmFOivvyf2ETTZ/i_78e61b249f75.jpg?credential=Ng7s5IScBmZ8GXNU03QieO8KTiRHSUwg&expires=1721895705&signature=F9cNod4BZ8JkH4cLkeXpKrb0hOA%3D",
          "comment": ""
        },
        {
          "url": "https://alpha-k.kakaocdn.net/dna/cYRmGW/bIcnbjCjCLi/kmUh8SzRzDGqwX5lPBnlam/i_9a4f0db69cc0.jpg?credential=Ng7s5IScBmZ8GXNU03QieO8KTiRHSUwg&expires=1721895705&signature=H0H3XSQa5Z3Lv3m%2BDtnHfrotxgg%3D",
          "comment": ""
        }
      ]
    }
    ```
  - 맨 처음 contents를 ES에서 text 포맷이라고 인지하고 text로 저장했는데, (이미 ES 매핑 고정됨) 타 포맷의 타입이 들어와서 충돌 -> 해당 문서 무시

- **해결**
  - req.body의 key-value 중에서 value가 object라면 stringify 시켜서 저장하자
  - 타 필드 역시 json 구조라면 안의 포맷이 변경될 가능성 있음. 

- **tips**
  - JavaScript에는 7가지 원시 타입(Primitive)만 존재
    - string, number, boolean, undefined, null, symbol, bigint
    ```js
    const flattenedBody = {};
    for (const key in req.body) {
        const value = req.body[key];
        if (value !== null && typeof value === 'object') {
            flattenedBody[key] = JSON.stringify(value);  // 중첩 → 문자열
        } else {
            flattenedBody[key] = value;  // 원시 타입 → 그대로
        }
    }
    ```
