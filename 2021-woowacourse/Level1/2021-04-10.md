### 2021-04-10

## 웹 애플리케이션 서버
- *참고 1: https://includestdio.tistory.com/25*
- *참고 2: https://victorydntmd.tistory.com/121*

- __웹 서버__
    - 정적 자원인 HTML/CSS/JS를 웹 클라이언트에게 제공
    - 요즘 웹 기술에서는 동적인 페이지 처리가 필요하면 웹 애플리케이션 서버에 요청을 넘김

- __웹 애플리케이션 서버__
    - 웹 서버로 부터 요청을 받아 처리, 해당 결과를 웹 서버로 반환
    - 주로 동적인 페이지 생성을 위한 DB 연동 등의 작업을 수행
    - 기존 CGI의 처리를 위해 프로세스 주구장창 만들던거 개선하고자 데몬으로 띄워놓기 시작
        - 이게 발전하여 웹 애플리케이션 서버가 탄생
        - JSP, ASP에서 WAS 방식 채택
    - 가장 대표적인 웹 애플리케이션 서버 Tomcat
    - 정적인 요청은 웹 서버에게, 동적인 요청은 웹 애플리케이션 서버가 하는게 더 많은 요청 처리할 수 있게함

- __굳이 웹 서버가 웹 애플리케이션 서버 앞에 있어야하나?__
    - WAS의 부하 줄여줌
    - WAS의 환경 설정 파일을 외부에 감춰줌
    
## 프로가 되기 위한 웹 기술 입문 5장
- __CGI 방식__
    - 기존에는 정적 웹페이지 하이퍼 링크로 연결해서 보여주는 걸로도 충분
    - 데이터베이스 연동이 필요해짐... 웹 서버와 별도의 프로그램 필요
        - 웹 서버 <--> 별도 프로그램 ... CGI
        - 웹 서버가 C, C++, Perl로 이루어진 프로그램 직접 호출해서 프로세스 생성
            - 근데 이게 별도 독립 프로세스 생성하자나?
            - 프로세스가 점유하는 메모리 많아지면 부하 BIG

- __웹 애플리케이션 서버의 등장__
    - JVM도 컴퓨터가 볼 땐 웹 서버/DB와 마찬가지로 하나의 프로세스
    - 즉, 웹 서버와는 독립된 프로세스로서 작동
    - JVM 상에서 애플리케이션 서버라는 소프트웨어가 작동되고 있고, 이 애플리케이션 서버가 서블릿/JSP를 작동시킴
        - 해당 애플리케이션 서버는 DB와 마찬가지로 항상 프로세스가 실행 중임. 

- __웹 서버와 웹 애플리케이션 서버의 연동__
    - 둘의 연동방법은 표준화 되어 있지 않음
    - 애플리케이션 서버 측이 주요 웹 서버별로 연동용 모듈을 마련해, 그 모듈을 웹 서버에 탑재함으로써 연동토록 함
        - Tomcat의 경우 mod_jk 연동 모듈 제공

- __웹 서버와 웹 애플리케이션 서버의 분담__
    - 서버 사이드에는 프로세스 2개가 연동하게 됨 (Web Server, WAS)
    - 마구잡이로 둘 중에 하나가 처리할 수 없으니...
        - 클라이언트의 HTTP 요청을 전부 웹 서버가 받고, URL에 따라 WAS가 처리할 요청을 보냄
        - ex. 아파치와 톰캣 간의 연동 설정을 workers.properties, httpd.conf에서 해주게 된다. 
    - 핵심은 웹 서버가 일단 창우가 되어 HTTP 요청을 접수, URL의 경로에 따라 WAS에 처리를 부탁한다는 것!
    - 웹 서버와 웹 애플리케이션 서버를 다른 노드로 분리할 수도 있음
        - 웹 애플리케이션 서버가 아무래도 서버의 작업량이 더 많음
        - 웹 서버와 웹 애플리케이션 서버를 다른 노드에 배치하면,  
        처리량은 가벼운 대신 횟수가 많은 정적 콘텐츠에 대한 요청운 웹서버,  
        횟수는 적지만 처리량이 무거운 동적 컨텐츠에 대한 요청은 웹 애플리케이션 서버로 다른 성격의 요청을 적절히 분담시킬 수 있음
    - 여러 대의 웹 애플리케이션 서버를 다른 노드에 배치해 분담시킬 수도 있음
        - 톰캣에서 여러 WAS로 요청 전송하도록 할 수 있다!
            - API에 따라 나누게 되는 건가?

- __웹 시스템의 구성__
    1. (웹 브라우저) <--> (AP 서버 <--> DBMS)
        - 웹 서버 생략
        - 소규모 시스템, 테스트 환경에서 많이 사용
    2. (웹 브라우저) <--> (웹 서버 <--> AP 서버 <--> DBMS)
        - 웹 서버 (아파치 등) 사용
    3. (웹 브라우저) <--> (웹 서버) <--> (AP 서버) <--> (DBMS)
        - 각 서버 별로 별도의 노드에 배치
        - 각 서버 별로 리소스 100% 사용 가능
    4. (웹 브라우저) <--> (웹 서버 <--> AP 서버) <--> (DBMS)
        - 데이터는 많고, 사용자는 그리 많지 않은 경우
            - ex. 기업 내 업무 시스템
            
## 체스 배포해보기
- 배포 주소: http://ec2-3-36-97-77.ap-northeast-2.compute.amazonaws.com/
- 배포 도전기: https://github.com/PapimonLikelion/woowacourse-TIL/blob/master/Level1/2021-04-03.md
- 배포 브랜치: https://github.com/PapimonLikelion/java-chess/tree/ubuntu

- __포트 삽질__
    - AWS EC2 인스턴스에서 HTTP 연결을 위한 포트를 개방해줘야 한다...
    - 기본적으로 22번 포트만 개방을 시켜주는데, 80번이 있어야 HTTP 연결을 할 수 있지 않겠니?
    - 443으로 HTTPS도 개방해줬는데 스파크자바에서 443으로 설정해서 할라고 하면 안되더라...?
        - 추가적인 보안이 필요한 듯?
        
- __sudo 삽질__
    - 우분투 일반 유저 계정에게는 1024번 이하 포트 바인딩이 불가
    - 나는 gradle로 빌드한 프로젝트를 ./gradlew run으로 실행하는데, 이는 일반 유저의 권한으로 실행하는 거야
        - sudo ./gradlew run으로 실행하면 superuser로써 프로그램을 구동할 수 있도록 함

- __0.0.0.0 vs 127.0.0.1__
    - 0.0.0.0은 모든 IP를 의미
        - 네트워크에 액세스 할 수 있는 곳이면 어디에서나 접근 가능
    - 127.0.0.1은 자기 스스로를 가르키는 IP
        - 동일한 기계에서만 액세스 할 수 있음
    
- __./gradlew__
    - 참고: https://docs.gradle.org/current/userguide/gradle_wrapper.html
    - 사용 이전에 선언된 Gradle 버전을 호출하여 빌드에 사용하는 스크립트
    - 개발자가 직접 수작업으로 설치하는 과정이 필요가 없어짐

- __nohup 명령어__
    - nohup 명령어를 통해 백그라운드에서 작업함과 동시에 터미널 세션 끊어도 프로세스 유지
