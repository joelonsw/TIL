### 2025-10-28

## TypeTag
- **개요**
  - JVM의 타입 이레이저 문제를 해결하기 위한 스칼라 고유의 reflection 도구
  - 컴파일 타입의 구체적인 타입 정보를 런타임까지 안전하게 배달해주는 역할

- **JVM의 Type Erasure**
  - JVM에서는 타입 이레이저라는 특징이 있음
  - `List[String]`과 `List[Int]`는 컴파일 시점에 서로 다른 타입이지만, 런타임에서는 정보가 모두 지워져 `List[Object]`로 보이게 됨
  - 따라서, 런타임에는 `List[String]`과 `List[Int]`를 구분할 방법이 없음

- **Scala TypeTag & ClassTag**
  - 스칼라 컴파일러가 컴파일 시점에 `T`의 정확한 타입 정보를 담은 객체(TypeTag)를 생성, 이를 런타임까지 implicit parameter로 전달
  - 이로써 런타임에 `T`의 정확한 제네릭 타임을 알아야만 하는 기능 구현시 필수
  - `ClassTag[T]`: 제네릭 정보를 제외한 최상위 클래스 정보만 있음
    - `List[String]`/`List[Int]` -> 모두 `List`
  - `TypeTag[T]`: 모든 중첩된 제네릭 정보 (`List[Map[String, Int]]` 등) Full Type 정보

- **TypeTag 용도**
  - 다음과 같이 리플렉션과 곁들여서 함께 사용
    ```scala
    private def accessors[T](tag: TypeTag[T]): List[MethodSymbol] = tag.tpe.members.collect {
        case m: MethodSymbol if m.isPublic && m.isCaseAccessor => m
    }.toList
    ```
  - 직렬화/역직렬화 라이브러리에서도 많이 사용. JSON을 어떤 Case class로 바꿀까요?
  - 고급 타입 안정성 및 DSL에서도 쓰임
