### 2025-05-29

## RabbitMQ Connection/Channel/Consumer
- **Connection**
  - RabbitMQ의 물리적인 TCP 연결
    - producer <-> rabbitmq
    - rabbitmq <-> consumer
  - 모든 trasnsport 레이어 커뮤니케이션에 대해서 담당

- **Channel**
  - 논리적인 connection. 어플리케이션 레벨에서 존재
  - "하나의 실제 TCP Connection"을 토대로 독립적인 여러 커뮤니케이션 스트림에 대한 멀티플렉싱 제공
    - 독립적인 커넥션으로 열어, 병렬적으로 각기 다른 처리 가능 (message pub/consuming)
    - 병렬적으로 동작해, TCP connection 오버헤드 줄여줌
  - Connection이 있어야 Channel이 존재
  - 각 channel은 독립적으로 동작해, 타 channel operation에 영향을 줄 수 없음
    - 싱글 프로세스에 따른 멀티 쓰레드 동작과 유사
    - connection 닫히면 channel도 다 닫힘
  - `Connection:Channel = 1:N`

- **Consumer**
  - queue에 대한 구독 -> 메시지 receive
  - Consumer는 특정한 Channel에 등록되고, RabbitMQ는 메시지를 해당 Channel을 통해 Consumer로 보냄
  - Consumer는 Channel에 바운드 되어 있음
  - `Channel: Consumer = 1:N`
    - Channel별 Consumer는 기본 최대 100. 하지만 많으면 좋을게 없음
  - Channel이 삭제되면, Consumer가 같이 사라짐
  - Consumer에 여러 메시지 전송 확인 직후 Channel이 닫히면, ACK 못받은 메시지 requeue됨

[비교 분석]
- **Queue별로 Channel 만들기 (멀티 채널)**
  - 구조)
    - `Queue A <-> Channel A <-> Consumer A`
    - `Queue B <-> Channel B <-> Consumer B`
  - 장점)
    - Isolation: 특정 채널에 오류 발생하더라도, 해당 큐만 영향 받음
    - 독립적 QoS 설정: prefetch_count 독립적으로 설정 가능
    - 명확한 흐름 관리: 하나의 큐 구독은 하나의 채널
  - 단점)
    - Connection 하나를 추가하여 만드는 약간의 추가 자원
  - channel을 Map으로 관리
    ```scala
    val channels = new ConcurrentHashMap[String, Channel]
    
    def createChannel(conn: Connection, prefetchCount: Int, channelKey: String) = {
        channels.remove(channelKey)
        
        val channel = conn.createChannel
        channel.basicQos(prefetchCount)
        channels.put(channelKey, channel)
        
        channel
    }
    ```

- **동일 Channel, Queue별 Consumer 만들기**
  - 구조)
    - `Queue A <-> Channel <-> Consumer A`
    - `Queue B <-> Channel <-> Consumer B`
  - 장점)
    - 최소한의 자원 사용. 간단한 코드레벨 구현?
  - 단점)
    - Isolation: 채널 하나 뻑나면 두개다 망가짐
    - 어플리케이션에서 한쪽에서 채널 뻑나면... 양쪽다 영향.
  - basicQos 메서드에서 global = false로 두면 각 consumer 별로 prefetchCount를 다르게 가져갈 수 있음
    ```scala
    def getConsumerQueueName: String, durable: Boolean = true, prefetchCount: Int = 1, actorRef: ActorRef): DefaultConsumer = {
        val channel = declareQueue(queueName, durable, prefetchCount)
        val consumer = new CustomConsumer(queueName, channel, actorRef)
        consumers.add(consumer)
        if (consuming) {
            consumer.startConsuming()
        }
        consumer
    }
    
    private def declareQueue(queueName: String, durable: Boolean = true, prefetchCount: Int): Channel = {
        val channel = getChannel
        channel.queueDeclarePassive(queueName)
        channel.basicQos(prefetchCount, false)  // void basicQos(int prefetchCount, boolean global) throws IOException;
        channel
    }
    ```
