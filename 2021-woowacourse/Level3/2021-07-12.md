### 2021-07-12

## 더 자바 [다이나믹 프록시]
- **java.lang.reflect.Proxy**
    - 쓰이는 곳 
        - Spring Data JPA
        - Spring AOP
- **프록시 패턴**
    - Client --> Interface
    - Interface의 실체는 Proxy
        - Proxy는 Real Subject를 가지고 있음        
    - ![](../image/2021-07-12-proxy-pattern.PNG)
    - Real Subject는 정말 핵심 비즈니스 로직만!
    - Proxy에서 추가적인 작업 수행
        - 로깅, 트랜잭션, 접근제한 등
- **다이나믹 프록시**
    - "런타임"에 하나 이상의 인터페이스들을 구현하는 클래스/인스턴스 만드는 기술
        - Proxy.newProxyInstance(클래스로더, 인터페이스의 목록, InvocationHandler)
            - 인터페이스의 목록: Java에서 제공하는 Proxy는 클래스 기반 Proxy 못 만듦
            - InvocationHandler: Proxy에 어떤 메서드가 호출될 때, 어떻게 처리할 것인가에 대한 설명... 여기에서 부가적인 처리!
    - 유연한 구조가 아님 ==> Spring AOP에서 개선!
- **클래스의 프록시가 필요하다면?**
    - 서브 클래스를 만들수 있는 라이브러리를 사용해 프록시를 만들자!
    - CGlib
        - 스프링/하이버네이트가 사용하는 라이브러리
        - 버전 호환성이 좋지 않아 라이브러리 내부에 내장된 형태
    - ByteBuddy
        - 바이트코드 조작 + 런타임 프록시 만들 때도 사용 가능
    - 서브 클래스 만드는 방법의 단점
        - 상속을 통한 프록시 생성이라, 상속이 불가능한 경우 프록시 못만들어 
            - private 생성자만 있는 경우
            - final 클래스 경우
        - 인터페이스가 있을 떄는 인터페이스의 프록시를 만들어 사용할 것

## 더 자바 [어노테이션 프로세서]
- **정의**
    - 소스코드 레벨에서 소스코드에 붙어있는 어노테이션의 정보를 읽어서, 컴파일러가 컴파일하는 중에 새로운 소스코드 생성/기존의 코드 변경
- **특징**
    - 클래스(바이트코드) 생성 가능
    - resource file 생성 가능
    - 런타임 비용이 제로
    - 기존 클래스 코드를 변경시 약간의 hack 필요
- **롬복**
    - 컴파일 시점에 어노테이션 프로세서를 사용해 소스코드의 AST를 조작함
    
## 사용자 이야기
- **사용자**
    - 사용자
        - 고객에게 가치를 전달할 수 없다면, 잘 작성된 코드가 아니다!
    - 사용자 리서치
        - 사용자가 이미 경험한 것들을 파악하면 사용자 스토리가 도출됨
        - 유사한 서비스를 사용하는 사용자 대상으로 리서치 하기
    - 페르소나 작성하기
        - 페르소나: 잠재 사용자들의 다양한 목적과 관찰된 행동 패턴을 응집시켜 놓은 것
        - 페르소나를 통해 제품을 정의/디자인할 수 있음
            - 공통된 '사용자'를 생각하며 작업 진행하자!
- **유저 스토리 도출**                    
    - 시나리오 제작
        - 시나리오는 페르소나 관점에서 기술
        - 페르소나에 의한 행동의 결과 -> 페르소나와 시스템 사이의 인터렉션 묘사
    - 시나리오에서 요구사항 도출
- **사용자를 고민에 빠뜨리지 말기**
    - 누구나 어려움없이 사용법을 알고, 투입한 수고에 비해 얻은 가치가 클 것!
    
